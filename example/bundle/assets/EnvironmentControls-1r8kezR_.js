import{g as at,b6 as ct,b as ht,V as S,j as ot,an as lt,k as P,ao as nt,aE as pt,R as dt,s as ut,Q as rt,i as mt}from"./three.module-CvwULque.js";class ft extends at{constructor(){super(new ct(0,0),new Pt),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class Pt extends ht{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new S},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const Q=new S,Y=new S;class vt{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){(t.pointerType==="mouse"||t.type==="wheel")&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const s=(this.domElement?this.domElement:t.target).getBoundingClientRect(),n=t.clientX-s.left,a=t.clientY-s.top;e.set(n,a)}addPointer(t){const e=t.pointerId,i=new S;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const s=i[0];return t.copy(e[s]),t}else if(this.getPointerCount()===2){const s=this.pointerOrder[0],n=this.pointerOrder[1],a=e[s],d=e[n];return t.addVectors(a,d).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(Q),this.getPreviousCenterPoint(Y),Q.sub(Y).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],s=e[1],n=t[i],a=t[s];return n.distanceTo(a)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const x=new ot,$=new lt,q=new P;function A(p,t,e){return e.makeTranslation(-p.x,-p.y,-p.z),x.makeRotationFromQuaternion(t),e.premultiply(x),x.makeTranslation(p.x,p.y,p.z),e.premultiply(x),e}function R(p,t,e,i){i.x=(p-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function Dt(p,t,e){return t.intersectRay(p,e)?e:(x.makeScale(...t.radius).invert(),$.copy(p).applyMatrix4(x),q.set(0,0,0),$.closestPointToPoint(q,e).normalize(),x.makeScale(...t.radius),e.applyMatrix4(x))}function Mt(p,t,e){const i=p.origin.length(),s=Math.acos(t/i);e.copy(p.origin).multiplyScalar(-1).normalize();const n=q.crossVectors(e,p.direction).normalize();e.multiplyScalar(-1).applyAxisAngle(n,-s).normalize().multiplyScalar(t)}function W(p,t,e){const{origin:i,direction:s}=p.ray;i.set(t.x,t.y,-1).unproject(e),s.set(t.x,t.y,1).unproject(e).sub(i),p.near=0,p.far=s.length(),p.camera=e,s.normalize()}const _=0,E=1,b=2,I=3,V=4,F=.05,Z=.025,gt=1e-4,yt=.01,D=new ot,U=new P,y=new P,j=new P,X=new P,z=new P,M=new rt,J=new nt,f=new P,H=new P,B=new P,St=new rt,L=new S,u=new S,K=new S,T=new S,N=new S,tt=new S,et={type:"change"},it={type:"start"},st={type:"end"};class xt extends pt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(t=null,e=null,i=null,s=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=_,this.pointerTracker=new vt,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new P,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new P,this.zoomPoint=new P,this.zoomDelta=0,this.rotationInertia=new S,this.dragInertia=new P,this.pivotMesh=new ft,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new dt,this.raycaster.firstHitOnly=!0,this.up=new P(0,1,0),this.clock=new ut,this.fallbackPlane=new nt(new P(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=_,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),s&&this.setTilesRenderer(s)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=t,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";let e=!1;const i=o=>{o.preventDefault()},s=o=>{o.key==="Shift"&&(e=!0)},n=o=>{o.key==="Shift"&&(e=!1)},a=o=>{o.preventDefault();const{camera:c,raycaster:l,domElement:C,up:k,pivotMesh:w,pointerTracker:g}=this;if(g.addPointer(o),this.needsUpdate=!0,g.isPointerTouch()){if(w.visible=!1,g.getPointerCount()===0)C.setPointerCapture(o.pointerId);else if(g.getPointerCount()>2){this.resetState();return}}g.getCenterPoint(u),R(u.x,u.y,C,u),W(l,u,c);const G=Math.abs(l.ray.direction.dot(k));if(G<F||G<Z)return;const O=this._raycast(l);O&&(g.getPointerCount()===2||g.isRightClicked()||g.isLeftClicked()&&e?(this.setState(g.isPointerTouch()?V:b),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)):g.isLeftClicked()&&(this.setState(E),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)))};let d=!1;const m=o=>{o.preventDefault(),this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==_&&(this.needsUpdate=!0);const{pointerTracker:c}=this;c.setHoverEvent(o),c.updatePointer(o)&&(c.isPointerTouch()&&c.getPointerCount()===2&&(d||(d=!0,queueMicrotask(()=>{d=!1,c.getCenterPoint(N);const l=c.getStartTouchPointerDistance(),C=c.getTouchPointerDistance(),k=C-l;if(this.state===_||this.state===V){c.getCenterPoint(N),c.getStartCenterPoint(tt);const w=2*window.devicePixelRatio,g=N.distanceTo(tt);(Math.abs(k)>w||g>w)&&(Math.abs(k)>g?(this.setState(I),this.zoomDirectionSet=!1):this.setState(b))}if(this.state===I){const w=c.getPreviousTouchPointerDistance();this.zoomDelta+=C-w}else this.state===b&&(this.pivotMesh.visible=this.enabled)}))),this.dispatchEvent(et))},h=o=>{const{pointerTracker:c}=this;c.deletePointer(o),c.getPointerType()==="touch"&&c.getPointerCount()===0&&t.releasePointerCapture(o.pointerId),this.resetState(),this.needsUpdate=!0},v=o=>{o.preventDefault();const{pointerTracker:c}=this;c.setHoverEvent(o),c.updatePointer(o),this.dispatchEvent(it);let l;switch(o.deltaMode){case 2:l=o.deltaY*100;break;case 1:l=o.deltaY*16;break;case 0:l=o.deltaY;break}const C=Math.sign(l),k=Math.log(Math.abs(l)+1);this.zoomDelta-=3*C*k,this.needsUpdate=!0,this._lastUsedState=I,this.dispatchEvent(st)},r=o=>{const{pointerTracker:c}=this;e=!1,o.buttons!==c.getPointerButtons()&&(c.deletePointer(o),this.resetState())};t.addEventListener("contextmenu",i),t.addEventListener("keydown",s),t.addEventListener("keyup",n),t.addEventListener("pointerdown",a),t.addEventListener("pointermove",m),t.addEventListener("pointerup",h),t.addEventListener("wheel",v,{passive:!1}),t.addEventListener("pointerenter",r),this._detachCallback=()=>{t.removeEventListener("contextmenu",i),t.removeEventListener("keydown",s),t.removeEventListener("keyup",n),t.removeEventListener("pointerdown",a),t.removeEventListener("pointermove",m),t.removeEventListener("pointerup",h),t.removeEventListener("wheel",v),t.removeEventListener("pointerenter",r)}}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){return this._lastUsedState===I?this._zoomPointWasSet?(t.copy(this.zoomPoint),t):null:this._lastUsedState===b||this._lastUsedState===E?(t.copy(this.pivotPoint),t):null}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==_&&this.dispatchEvent(st),this.state=_,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0}setState(t=this.state,e=!0){this.state!==t&&(this.state===_&&e&&this.dispatchEvent(it),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.state=t,t!==_&&t!==V&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:e,cameraRadius:i,pivotPoint:s,up:n,state:a,adjustHeight:d}=this;e.updateMatrixWorld(),this.getCameraUpDirection(f),this._upInitialized||(this._upInitialized=!0,this.up.copy(f));const m=this._inertiaNeedsUpdate();if(this.needsUpdate||m){const r=this.zoomDelta;(a===I||r!==0)&&(this._updateZoom(),this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0)),this._updatePosition(t),this._updateRotation(t),(a!==_||r!==0||m)&&this.dispatchEvent(et),this.needsUpdate=!1}m&&this._updateInertiaDamping(t);const h=e.isOrthographicCamera?null:d&&this._getPointBelowCamera()||null,v=e.isOrthographicCamera?s:h&&h.point||null;if(this.getCameraUpDirection(f),this._setFrame(f,v),(this.state===E||this.state===b)&&this.actionHeightOffset!==0){const{actionHeightOffset:r}=this;e.position.addScaledVector(n,-r),s.addScaledVector(n,-r),h&&(h.distance-=r)}if(this.actionHeightOffset=0,h){const r=h.distance;if(r<i){const o=i-r;e.position.addScaledVector(n,o),s.addScaledVector(n,o),this.actionHeightOffset=o}}this.pointerTracker.updateFrame()}adjustCamera(t){const{adjustHeight:e,cameraRadius:i}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,f);const s=e&&this._getPointBelowCamera(t.position,f)||null;if(s){const n=s.distance;n<i&&t.position.addScaledVector(f,i-n)}}}dispose(){this.detach()}_updateInertiaDamping(t){const{rotationInertia:e,dragInertia:i,enableDamping:s,dampingFactor:n}=this,a=Math.pow(2,-t/n);e.multiplyScalar(a),(e.lengthSq()<gt||!s)&&e.set(0,0),i.multiplyScalar(a),(i.lengthSq()<yt||!s)&&i.set(0,0,0)}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return t.lengthSq()!==0||e.lengthSq()!==0}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:s,maxDistance:n,pointerTracker:a,domElement:d,minZoom:m,maxZoom:h,zoomSpeed:v}=this;let r=this.zoomDelta;if(this.zoomDelta=0,!!a.getLatestPoint(u))if(i.isOrthographicCamera){this._updateZoomDirection();const o=this.zoomPointSet||this._updateZoomPoint();H.unproject(i);const c=Math.pow(.95,Math.abs(r*.05));let l=r>0?1/Math.abs(c):c;l*=v,l>1?h<i.zoom*l&&(l=1):m>i.zoom*l&&(l=1),i.zoom*=l,i.updateProjectionMatrix(),o&&(R(u.x,u.y,d,B),B.unproject(i),i.position.sub(B).add(H),i.updateMatrixWorld())}else{this._updateZoomDirection();const o=y.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const c=t.distanceTo(i.position);if(r<0){const l=Math.min(0,c-n);r=r*c*v*.0025,r=Math.max(r,l)}else{const l=Math.max(0,c-s);r=r*Math.max(c-s,0)*v*.0025,r=Math.min(r,l)}i.position.addScaledVector(e,r),i.updateMatrixWorld()}else{const c=this._getPointBelowCamera();if(c){const l=c.distance;o.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(o,r*l*.01),i.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:i,zoomDirection:s,pointerTracker:n}=this;n.getLatestPoint(u),R(u.x,u.y,t,H),W(e,H,i),s.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:s,zoomPoint:n,pointerTracker:a,domElement:d}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&a.getLatestPoint(L)?(R(L.x,L.y,d,L),W(s,L,t)):(s.ray.origin.copy(t.position),s.ray.direction.copy(i),s.near=0,s.far=1/0);const m=this._raycast(s);return m?(n.copy(m.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:i}=this;i.ray.direction.copy(e).multiplyScalar(-1),i.ray.origin.copy(t).addScaledVector(e,1e5),i.near=0,i.far=1/0;const s=this._raycast(i);return s&&(s.distance-=1e5),s}_updatePosition(t){const{raycaster:e,camera:i,pivotPoint:s,up:n,pointerTracker:a,domElement:d,state:m,dragInertia:h,enableDamping:v}=this;if(m===E){if(a.getCenterPoint(u),R(u.x,u.y,d,u),J.setFromNormalAndCoplanarPoint(n,s),W(e,u,i),Math.abs(e.ray.direction.dot(n))<F){const r=Math.acos(F);z.crossVectors(e.ray.direction,n).normalize(),e.ray.direction.copy(n).applyAxisAngle(z,r).multiplyScalar(-1)}if(this.getUpDirection(s,f),Math.abs(e.ray.direction.dot(f))<Z){const r=Math.acos(Z);z.crossVectors(e.ray.direction,f).normalize(),e.ray.direction.copy(f).applyAxisAngle(z,r).multiplyScalar(-1)}e.ray.intersectPlane(J,y)&&(U.subVectors(s,y),i.position.add(U),i.updateMatrixWorld(),U.multiplyScalar(1/t),a.getMoveDistance()/t<2*window.devicePixelRatio?h.lerp(U,.5):h.copy(U))}else v&&(i.position.addScaledVector(h,t),i.updateMatrixWorld())}_updateRotation(t){const{pivotPoint:e,pointerTracker:i,domElement:s,state:n,rotationInertia:a,enableDamping:d}=this;n===b?(i.getCenterPoint(u),i.getPreviousCenterPoint(K),T.subVectors(u,K).multiplyScalar(2*Math.PI/s.clientHeight),this._applyRotation(T.x,T.y,e),T.multiplyScalar(1/t),i.getMoveDistance()/t<2*window.devicePixelRatio?a.lerp(T,.5):a.copy(T)):d&&this._applyRotation(a.x*t,a.y*t,e)}_applyRotation(t,e,i){if(t===0&&e===0)return;const{camera:s,minAltitude:n,maxAltitude:a,rotationSpeed:d}=this,m=-t*d;let h=e*d;j.set(0,0,1).transformDirection(s.matrixWorld),this.getUpDirection(i,f),y.crossVectors(f,j).normalize(),X.set(1,0,0).transformDirection(s.matrixWorld).normalize();const r=Math.sign(y.dot(X))*f.angleTo(j);h>0?(h=Math.min(r-n-.01,h),h=Math.max(0,h)):(h=Math.max(r-a,h),h=Math.min(0,h)),M.setFromAxisAngle(f,m),A(i,M,D),s.matrixWorld.premultiply(D),z.set(-1,0,0).transformDirection(s.matrixWorld),M.setFromAxisAngle(z,h),A(i,M,D),s.matrixWorld.premultiply(D),s.matrixWorld.decompose(s.position,s.quaternion,y)}_setFrame(t,e){const{up:i,camera:s,state:n,zoomPoint:a,zoomDirectionSet:d,zoomPointSet:m,reorientOnDrag:h,scaleZoomOrientationAtEdges:v}=this;s.updateMatrixWorld(),M.setFromUnitVectors(i,t);const r=n;if(d&&(m||this._updateZoomPoint())){if(this.getUpDirection(a,y),v){let o=Math.max(y.dot(i)-.6,0)/.4;o=mt.mapLinear(o,0,.5,0,1),o=Math.min(o,1),s.isOrthographicCamera&&(o*=.1),M.slerp(St,1-o)}A(a,M,D),s.matrixWorld.premultiply(D),s.matrixWorld.decompose(s.position,s.quaternion,y),this.zoomDirectionSet=!1,this._updateZoomDirection()}else r===E&&h&&e&&(A(e,M,D),s.matrixWorld.premultiply(D),s.matrixWorld.decompose(s.position,s.quaternion,y));i.copy(t),s.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:s}=this,n=t.intersectObject(e)[0]||null;if(n)return n;if(i){const a=s;if(t.ray.intersectPlane(a,y))return{point:y.clone(),distance:t.ray.origin.distanceTo(y)}}return null}}export{E as D,xt as E,_ as N,R as a,Mt as b,Dt as c,A as m,W as s};
