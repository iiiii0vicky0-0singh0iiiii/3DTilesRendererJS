import{r as z,F as Z,B as J,a as q}from"./readMagicBytes-Da5ueiou.js";import{L as K}from"./LoaderBase-CVSPpjX2.js";import{j as M,bn as X,k as L,bo as Y,Q as k}from"./three.module-CvwULque.js";import{G as tt}from"./GLTFLoader-nx88wwE7.js";import{E as et}from"./Ellipsoid-LZ-ZKZQp.js";const pt=-1,Tt=0,ht=1,ut=2,gt=3,y=6378137,st=1/298.257223563,at=-(st*y-y);class nt extends K{parse(o){const a=new DataView(o),s=z(a);console.assert(s==="i3dm");const A=a.getUint32(4,!0);console.assert(A===1);const U=a.getUint32(8,!0);console.assert(U===o.byteLength);const S=a.getUint32(12,!0),b=a.getUint32(16,!0),i=a.getUint32(20,!0),f=a.getUint32(24,!0),m=a.getUint32(28,!0),h=32,R=o.slice(h,h+S+b),n=new Z(R,0,S,b),e=h+S+b,p=o.slice(e,e+i+f),E=new J(p,n.getData("INSTANCES_LENGTH"),0,i,f),d=e+i+f,u=new Uint8Array(o,d,U-d);let N=null,T=null,w=null;if(m)N=u,T=Promise.resolve();else{const r=this.resolveExternalURL(q(u)),g=r.split(/[\\/]/g);g.pop(),w=g.join("/"),T=fetch(r,this.fetchOptions).then(c=>{if(!c.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${r}" with status ${c.status} : ${c.statusText}`);return c.arrayBuffer()}).then(c=>{N=new Uint8Array(c)})}return T.then(()=>({version:A,featureTable:n,batchTable:E,glbBytes:N,gltfWorkingPath:w}))}}const Q=new et(y,y,at);Q.name="WGS84 Earth";const W=new L,F=new L,C=new L,P=new L,x=new k,I=new L,_=new M,H=new M,V=new L,v=new M,B=new k,G={};class Lt extends nt{constructor(o=X){super(),this.manager=o,this.adjustmentTransform=new M,this.ellipsoid=Q.clone()}resolveExternalURL(o){return this.manager.resolveURL(super.resolveExternalURL(o))}parse(o){return super.parse(o).then(a=>{const{featureTable:s,batchTable:A}=a,U=a.glbBytes.slice().buffer;return new Promise((S,b)=>{const i=this.fetchOptions,f=this.manager,m=f.getHandler("path.gltf")||new tt(f);i.credentials==="include"&&i.mode==="cors"&&m.setCrossOrigin("use-credentials"),"credentials"in i&&m.setWithCredentials(i.credentials==="include"),i.headers&&m.setRequestHeader(i.headers);let h=a.gltfWorkingPath??this.workingPath;/[\\/]$/.test(h)||(h+="/");const R=this.adjustmentTransform;m.parse(U,h,n=>{const e=s.getData("INSTANCES_LENGTH"),p=s.getData("POSITION",e,"FLOAT","VEC3"),E=s.getData("NORMAL_UP",e,"FLOAT","VEC3"),d=s.getData("NORMAL_RIGHT",e,"FLOAT","VEC3"),u=s.getData("SCALE_NON_UNIFORM",e,"FLOAT","VEC3"),N=s.getData("SCALE",e,"FLOAT","SCALAR"),T=s.getData("RTC_CENTER"),w=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(t=>{t in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)});const r=new L;for(let t=0;t<e;t++)r.x+=p[t*3+0]/e,r.y+=p[t*3+1]/e,r.z+=p[t*3+2]/e;const g=[],c=[];n.scene.updateMatrixWorld(),n.scene.traverse(t=>{if(t.isMesh){c.push(t);const{geometry:O,material:D}=t,l=new Y(O,D,e);l.position.copy(r),T&&(l.position.x+=T[0],l.position.y+=T[1],l.position.z+=T[2]),g.push(l)}});for(let t=0;t<e;t++){P.set(p[t*3+0]-r.x,p[t*3+1]-r.y,p[t*3+2]-r.z),x.identity(),E&&(F.set(E[t*3+0],E[t*3+1],E[t*3+2]),C.set(d[t*3+0],d[t*3+1],d[t*3+2]),W.crossVectors(C,F).normalize(),_.makeBasis(C,F,W),x.setFromRotationMatrix(_)),I.set(1,1,1),u&&I.set(u[t*3+0],u[t*3+1],u[t*3+2]),N&&I.multiplyScalar(N[t]);for(let O=0,D=g.length;O<D;O++){const l=g[O];B.copy(x),w&&(l.updateMatrixWorld(),V.copy(P).applyMatrix4(l.matrixWorld),this.ellipsoid.getPositionToCartographic(V,G),this.ellipsoid.getEastNorthUpFrame(G.lat,G.lon,v),B.setFromRotationMatrix(v)),_.compose(P,B,I).multiply(R);const $=c[O];H.multiplyMatrices(_,$.matrixWorld),l.setMatrixAt(t,H)}}n.scene.clear(),n.scene.add(...g),n.batchTable=A,n.featureTable=s,n.scene.batchTable=A,n.scene.featureTable=s,S(n)},b)})})}}export{pt as F,Lt as I,gt as L,ut as P,Tt as U,Q as W,ht as a};
